@inject IResourceService ResourceService
@inject ISnackbar Snackbar
@inject ILogger<AppServiceDetails> Logger

@if (Resource is null)
{
    <MudAlert Severity="Severity.Info">No App Service data.</MudAlert>
}
else
{
    <MudPaper Class="pa-4 mb-3">
        <MudText Typo="Typo.h6" Class="mb-3">App Service</MudText>
        <MudText Color="Color.Secondary" Typo="Typo.caption">Kind</MudText>
        <MudText>@GetMetadata("kind")</MudText>
    </MudPaper>

    <MudPaper Class="pa-4 mb-3">
        <MudText Typo="Typo.h6" Class="mb-2">Lifecycle</MudText>
        <MudText Color="Color.Secondary" Typo="Typo.caption">Actions</MudText>
        <MudText Color="Color.Secondary" Typo="Typo.caption">Status: @(GetStatusDisplay() ?? "Unknown")</MudText>
        <MudStack Row="true" Spacing="2" Class="mt-2">
            <MudButton Variant="Variant.Filled"
                       Color="Color.Success"
                       Disabled="@(IsDisabled || IsRunning)"
                       OnClick="StartAsync">
                Start
            </MudButton>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Error"
                       Disabled="@(IsDisabled || IsStopped)"
                       OnClick="StopAsync">
                Stop
            </MudButton>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       Disabled="@IsDisabled"
                       OnClick="RestartAsync">
                Restart
            </MudButton>
        </MudStack>
        @if (IsDisabled)
        {
            <MudText Color="Color.Secondary" Typo="Typo.caption" Class="mt-2">
                Requires an available service principal to run lifecycle actions.
            </MudText>
        }
    </MudPaper>

    <MudPaper Class="pa-4 mb-3 diagnostics-paper">
        <MudText Typo="Typo.h6" Class="mb-2">Diagnostics</MudText>
        @if (metricsLoading)
        {
            <MudProgressLinear Indeterminate="true" Color="Color.Primary" Class="mb-2" />
            <MudText Color="Color.Secondary">Loading metrics...</MudText>
        }
        else if (!string.IsNullOrWhiteSpace(metricsError))
        {
            <MudAlert Severity="Severity.Error">@metricsError</MudAlert>
        }
        else if (metricCharts.Count == 0)
        {
            <MudText Color="Color.Secondary">No metrics available.</MudText>
        }
        else
        {
            @foreach (var chart in metricCharts)
            {
                <div class="mb-3">
                    <MudText Typo="Typo.subtitle2" Class="mb-1">@chart.Name</MudText>
                    <MudTimeSeriesChart ChartSeries="@chart.Series"
                                        ChartOptions="@chartOptions"
                                        AxisChartOptions="@axisOptions"
                                        CanHideSeries="false"
                                        TimeLabelSpacing="TimeSpan.FromMinutes(5)"
                                        Width="100%"
                                        Height="100%"
                                        @key="chart.ChartKey"
                                        Class="diagnostics-chart" />
                </div>
            }
        }
    </MudPaper>
}

@code {
    [Parameter] public Resource? Resource { get; set; }
    [Parameter] public ServicePrincipal? ServicePrincipal { get; set; }
    [Parameter] public string? Status { get; set; }
    [Parameter] public bool Disabled { get; set; }

    private bool busy;
    private bool metricsLoading;
    private string? metricsError;
    private List<MetricChart> metricCharts = new();
    private CancellationTokenSource? loadCts;
    private bool disposed;

    private readonly ChartOptions chartOptions = new()
    {
        YAxisTicks = 5
    };
    private readonly AxisChartOptions axisOptions = new();

    private bool IsDisabled => Disabled || busy || ServicePrincipal is null;

    protected override async Task OnParametersSetAsync()
    {
        loadCts?.Cancel();
        loadCts = new CancellationTokenSource();

        if (Resource is not null && ServicePrincipal is not null)
        {
            await LoadMetricsAsync(loadCts.Token);
        }
    }

    private string GetMetadata(string key)
    {
        if (Resource?.Metadata is null)
        {
            return "-";
        }

        foreach (var kvp in Resource.Metadata)
        {
            if (string.Equals(kvp.Key, key, StringComparison.OrdinalIgnoreCase))
            {
                return string.IsNullOrWhiteSpace(kvp.Value) ? "-" : kvp.Value;
            }
        }

        return "-";
    }

    private string GetStatusRaw()
    {
        if (!string.IsNullOrWhiteSpace(Status))
        {
            return Status;
        }

        var status = GetMetadata("status");
        if (string.Equals(status, "-", StringComparison.Ordinal)) status = GetMetadata("state");
        return status;
    }

    private string? GetStatusDisplay()
    {
        var status = GetStatusRaw();
        return string.IsNullOrWhiteSpace(status) || status == "-" ? null : status;
    }

    private bool IsRunning
    {
        get
        {
            var status = GetStatusRaw();
            return !string.IsNullOrWhiteSpace(status) && status != "-" &&
                   (status.Contains("run", StringComparison.OrdinalIgnoreCase) || status.Contains("start", StringComparison.OrdinalIgnoreCase));
        }
    }

    private bool IsStopped
    {
        get
        {
            var status = GetStatusRaw();
            return !string.IsNullOrWhiteSpace(status) && status != "-" &&
                   status.Contains("stop", StringComparison.OrdinalIgnoreCase);
        }
    }

    private async Task RestartAsync()
    {
        if (Resource is null || ServicePrincipal is null)
        {
            Snackbar.Add("Missing resource or service principal for restart.", Severity.Error);
            return;
        }

        busy = true;
        try
        {
            await ResourceService.RestartAsync(ServicePrincipal, Resource, new RestartAction { WaitAfterSeconds = 10 });
            Snackbar.Add("App Service restart initiated.", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to restart App Service {ResourceId}", Resource.Id);
            Snackbar.Add($"Restart failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            busy = false;
        }
    }

    private async Task StartAsync()
    {
        if (Resource is null || ServicePrincipal is null)
        {
            Snackbar.Add("Missing resource or service principal for start.", Severity.Error);
            return;
        }

        busy = true;
        try
        {
            await ResourceService.StartAsync(ServicePrincipal, Resource);
            Snackbar.Add("Start request sent.", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start App Service {ResourceId}", Resource.Id);
            Snackbar.Add($"Start failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            busy = false;
        }
    }

    private async Task StopAsync()
    {
        if (Resource is null || ServicePrincipal is null)
        {
            Snackbar.Add("Missing resource or service principal for stop.", Severity.Error);
            return;
        }

        busy = true;
        try
        {
            await ResourceService.StopAsync(ServicePrincipal, Resource);
            Snackbar.Add("Stop request sent.", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to stop App Service {ResourceId}", Resource.Id);
            Snackbar.Add($"Stop failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            busy = false;
        }
    }

    private async Task LoadMetricsAsync(CancellationToken cancellationToken)
    {
        if (Resource is null || ServicePrincipal is null)
        {
            return;
        }

        metricsLoading = true;
        metricsError = null;
        try
        {
            var result = await ResourceService.GetMetricsAsync(ServicePrincipal, Resource);
            if (disposed || cancellationToken.IsCancellationRequested)
            {
                return;
            }
            if (result is null || result.Series.Count == 0)
            {
                metricCharts = new List<MetricChart>();
                return;
            }

            var charts = new List<MetricChart>();
            foreach (var series in result.Series)
            {
                var data = series.Points
                    .OrderBy(p => p.Timestamp)
                    .Select(p => new TimeSeriesChartSeries.TimeValue(p.Timestamp, NormalizeValue(series.Name, p.Value)))
                    .ToList();

                if (data.Any(v => Math.Abs(v.Value) > double.Epsilon))
                {
                    var chartSeries = new TimeSeriesChartSeries
                    {
                        Index = charts.Count,
                        Name = series.Name,
                        Data = data,
                        IsVisible = true,
                        LineDisplayType = LineDisplayType.Line
                    };

                    charts.Add(new MetricChart
                    {
                        Name = series.Name,
                        Series = new List<TimeSeriesChartSeries> { chartSeries },
                        ChartKey = Guid.NewGuid()
                    });
                }
            }

            if (charts.Count == 0)
            {
                metricCharts = new List<MetricChart>();
                return;
            }

            metricCharts = charts;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load metrics for App Service {ResourceId}", Resource.ResourceId);
            metricsError = $"Failed to load metrics: {ex.Message}";
        }
        finally
        {
            metricsLoading = false;
            if (!disposed && !cancellationToken.IsCancellationRequested)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private static double NormalizeValue(string seriesName, double? value)
    {
        var val = value ?? 0d;
        if (double.IsNaN(val) || double.IsInfinity(val))
        {
            return 0d;
        }

        if (seriesName.Contains("Memory", StringComparison.OrdinalIgnoreCase))
        {
            return val / (1024d * 1024d); // bytes -> MB
        }

        return val;
    }

    public void Dispose()
    {
        disposed = true;
        loadCts?.Cancel();
        loadCts?.Dispose();
    }

    private sealed class MetricChart
    {
        public string Name { get; init; } = string.Empty;
        public List<TimeSeriesChartSeries> Series { get; init; } = new();
        public Guid ChartKey { get; init; }
    }
}
